<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Entropy Sea: Director's Cut</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Italiana&family=Montserrat:wght@200;400&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #020205; 
            font-family: 'Montserrat', sans-serif;
            color: #fff;
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 4vh; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        header {
            display: flex; justify-content: space-between; align-items: flex-start;
            mix-blend-mode: difference;
        }

        h1 {
            font-family: 'Italiana', serif;
            font-size: 3rem; margin: 0;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        /* Status & Cam */
        .status-block { text-align: right; }
        
        #state-label {
            font-family: 'Italiana', serif; font-size: 2rem;
            transition: all 0.5s ease;
            text-shadow: 0 0 10px currentColor;
        }

        #cam-preview {
            margin-top: 15px; width: 120px; height: 90px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px; opacity: 0.6;
            transform: scaleX(-1); object-fit: cover;
        }

        /* Init Overlay */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        button {
            pointer-events: auto;
            background: transparent; color: #fff;
            border: 1px solid rgba(255,255,255,0.4);
            padding: 20px 60px;
            font-family: 'Italiana', serif; font-size: 1.2rem; letter-spacing: 0.2em;
            cursor: pointer; transition: all 0.4s ease;
            margin-top: 40px;
            background: rgba(255,255,255,0.05);
        }
        button:hover {
            background: #fff; color: #000;
            box-shadow: 0 0 40px rgba(255,255,255,0.6);
        }

        /* Instructions */
        .controls {
            display: flex; gap: 60px;
            font-size: 0.7rem; letter-spacing: 0.2em; opacity: 0.7;
            text-transform: uppercase; align-items: flex-end;
        }
        .control-item b { display: block; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.4); padding-bottom: 5px; margin-bottom: 5px; color: #fff;}
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="overlay">
        <h1 style="font-size: 5vw; margin-bottom: 0;">Entropy Sea</h1>
        <div style="width: 50px; height: 1px; background: #fff; margin: 20px 0;"></div>
        <button id="start-btn">INITIALIZE</button>
        <div style="margin-top: 20px; font-size: 0.7rem; opacity: 0.4; letter-spacing: 0.2em;">USE HEADPHONES FOR IMMERSION</div>
    </div>

    <div id="ui-layer">
        <header>
            <h1>Entropy Sea</h1>
            <div class="status-block">
                <div id="state-label">VOID</div>
                <video id="cam-preview" autoplay playsinline muted></video>
            </div>
        </header>

        <div style="flex-grow:1"></div>

        <div class="controls">
            <div class="control-item"><b>Open Hand</b>Sun / Deep Ocean</div>
            <div class="control-item"><b>Fist</b>Ice / Crystallize</div>
            <div class="control-item"><b>Wave</b>Storm / Turbulence</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // ==========================================
        // 1. AUDIO ENGINE 3.0 (Atmospheric & Musical)
        // ==========================================
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.connect(this.ctx.destination);
                this.master.gain.value = 0.5;

                // Create Mix Busses
                this.sunBus = this.createBus();
                this.stormBus = this.createBus();
                this.iceBus = this.createBus();

                // Start Generators
                this.initSunPad();
                this.initStormDrone();
                this.initIceBells();
            }

            createBus() {
                const g = this.ctx.createGain();
                g.connect(this.master);
                g.gain.value = 0;
                return g;
            }

            resume() {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            // SUN: Deep, Warm Ocean Drone (Eb Major)
            initSunPad() {
                // Frequencies for Eb Major 9: Eb2, Bb2, D3, G3, Bb3
                const freqs = [77.78, 116.54, 146.83, 196.00, 233.08]; 
                
                freqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = i === 0 ? 'sine' : 'triangle'; // Deep sine for bass
                    osc.frequency.value = f;

                    // Filter to soften the sound
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400 + Math.random() * 200;

                    const pan = this.ctx.createStereoPanner();
                    pan.pan.value = (Math.random() * 2 - 1) * 0.4;

                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.1 / freqs.length; 

                    // LFO for "breathing" effect
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.05 + Math.random() * 0.05;
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.05; // Amplitude modulation
                    lfo.connect(lfoGain).connect(gain.gain);

                    osc.connect(filter).connect(pan).connect(gain).connect(this.sunBus);
                    osc.start();
                    lfo.start();
                });
            }

            // STORM: Filtered Pink Noise + Low Rumble
            initStormDrone() {
                const bufferSize = 2 * this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);

                // Pink Noise Algorithm
                let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    output[i] *= 0.11; 
                    b6 = white * 0.115926;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                // Dynamic Filter simulates wind howling
                this.stormFilter = this.ctx.createBiquadFilter();
                this.stormFilter.type = 'bandpass';
                this.stormFilter.frequency.value = 200;
                this.stormFilter.Q.value = 1.5;

                noise.connect(this.stormFilter).connect(this.stormBus);
                noise.start();
            }

            // ICE: Crystalline Bells (FM Synthesis)
            initIceBells() {
                // High Pitched Pentatonic: Eb5, G5, Bb5, D6, Eb6
                const scale = [622.25, 783.99, 932.33, 1174.66, 1244.51];
                
                const playNote = () => {
                    if (this.iceBus.gain.value > 0.05) {
                        const freq = scale[Math.floor(Math.random() * scale.length)];
                        const t = this.ctx.currentTime;

                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, t);

                        // FM Modulator for "glassy" texture
                        const mod = this.ctx.createOscillator();
                        mod.frequency.value = freq * 2.0; 
                        const modGain = this.ctx.createGain();
                        modGain.gain.setValueAtTime(800, t);
                        modGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                        mod.connect(modGain).connect(osc.frequency);

                        // Amplitude Envelope
                        const env = this.ctx.createGain();
                        env.gain.setValueAtTime(0, t);
                        env.gain.linearRampToValueAtTime(0.3, t + 0.01);
                        env.gain.exponentialRampToValueAtTime(0.001, t + 2.0);

                        // Panning
                        const pan = this.ctx.createStereoPanner();
                        pan.pan.value = Math.random() * 2 - 1;

                        osc.connect(env).connect(pan).connect(this.iceBus);
                        
                        osc.start(t);
                        mod.start(t);
                        osc.stop(t + 2.5);
                        mod.stop(t + 2.5);
                    }
                    setTimeout(playNote, 150 + Math.random() * 400); // Random interval
                };
                playNote();
            }

            update(wSun, wStorm, wIce) {
                const t = this.ctx.currentTime;
                // Smooth crossfading
                this.sunBus.gain.setTargetAtTime(wSun * 1.5, t, 0.2); // Boost Sun volume slightly
                this.stormBus.gain.setTargetAtTime(wStorm * 2.0, t, 0.2); 
                this.iceBus.gain.setTargetAtTime(wIce, t, 0.2);

                // Storm Wind Simulation
                if (wStorm > 0.1) {
                    const windFreq = 150 + wStorm * 800 + Math.sin(t) * 100;
                    this.stormFilter.frequency.setTargetAtTime(windFreq, t, 0.1);
                }
            }
        }

        // ==========================================
        // 2. MATHEMATICS (Aztec Diamond Engine)
        // ==========================================
        class AztecEngine {
            constructor(n) {
                this.n = n;
                this.size = 2 * n;
                this.grid = new Int8Array(this.size * this.size);
                this.nextGrid = new Int8Array(this.size * this.size);
                this.init();
            }

            init() {
                // Fill with valid checkerboard tiling
                for(let y=0; y<this.size; y+=2) {
                    for(let x=0; x<this.size; x+=2) {
                        if ((x/2 + y/2) % 2 === 0) {
                            this.grid[(y)*this.size+x] = 1; this.grid[(y+1)*this.size+x] = 2;
                            this.grid[(y)*this.size+x+1] = 1; this.grid[(y+1)*this.size+x+1] = 2;
                        } else {
                            this.grid[(y)*this.size+x] = 3; this.grid[(y)*this.size+x+1] = 4;
                            this.grid[(y+1)*this.size+x] = 3; this.grid[(y+1)*this.size+x+1] = 4;
                        }
                    }
                }
            }

            iterate(verticalBias) {
                const sz = this.size;
                this.nextGrid.fill(0);
                
                // 1. Move
                for(let i=0; i<this.grid.length; i++) {
                    const t = this.grid[i];
                    if(t===0) continue;
                    let y = Math.floor(i/sz), x = i%sz;
                    if(t===1) y--; else if(t===2) y++; else if(t===3) x--; else if(t===4) x++;
                    if(x>=0 && x<sz && y>=0 && y<sz) this.nextGrid[y*sz+x] = t;
                }
                
                // 2. Fill (Entropy)
                for(let y=0; y<sz-1; y++) {
                    for(let x=0; x<sz-1; x++) {
                        const idx = y*sz+x;
                        // Identify 2x2 hole
                        if(this.nextGrid[idx]===0 && this.nextGrid[idx+1]===0 &&
                           this.nextGrid[idx+sz]===0 && this.nextGrid[idx+sz+1]===0) {
                            // Bias determines Crystal (Vert) vs Liquid (Horiz)
                            if(Math.random() < verticalBias) {
                                this.nextGrid[idx]=1; this.nextGrid[idx+sz]=2;
                                this.nextGrid[idx+1]=1; this.nextGrid[idx+sz+1]=2;
                            } else {
                                this.nextGrid[idx]=3; this.nextGrid[idx+1]=4;
                                this.nextGrid[idx+sz]=3; this.nextGrid[idx+sz+1]=4;
                            }
                        }
                    }
                }
                this.grid.set(this.nextGrid);
            }
        }

        // ==========================================
        // 3. VISUAL ENGINE (The Deep Blue Sea)
        // ==========================================
        async function initVisuals() {
            // Setup Three.js
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.02); // Deep blue-black fog

            const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 60);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            // Golden Sun Light
            const sunLight = new THREE.DirectionalLight(0xffaa33, 2.0);
            sunLight.position.set(50, 40, -50);
            scene.add(sunLight);

            // Ambient Deep Blue Light (The Sea Base)
            const ambient = new THREE.AmbientLight(0x001133, 0.4); 
            scene.add(ambient);

            // --- INSTANCED MESH ---
            const CONFIG = { n: 60, tileSize: 0.5 }; // High resolution grid
            const aztec = new AztecEngine(CONFIG.n);
            const count = aztec.size * aztec.size;

            // --- SHADER MATERIAL: THE OCEAN ---
            const tileMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uHandPos: { value: new THREE.Vector2(0,0) },
                    wSun: { value: 1.0 },
                    wStorm: { value: 0.0 },
                    wIce: { value: 0.0 },
                    // Environment Colors
                    uDeepWater: { value: new THREE.Color("#00081a") }, // Very Dark Blue
                    uShallowWater: { value: new THREE.Color("#004488") }, // Lighter Blue
                    uSunLight: { value: new THREE.Color("#ffdd88") } // Golden Highlight
                },
                vertexShader: `
                    varying vec3 vWorldPos;
                    varying vec3 vNormal;
                    varying float vElevation;
                    varying vec2 vUv;
                    attribute float aType;

                    uniform float uTime;
                    uniform vec2 uHandPos;
                    uniform float wSun;
                    uniform float wStorm;
                    uniform float wIce;

                    // Gerstner Wave approximation
                    vec3 gerstner(vec3 pos, float time) {
                        float waveLen = 10.0;
                        float speed = 1.5;
                        float amp = 1.0;
                        float freq = 2.0 / waveLen;
                        float phase = speed * freq;
                        float theta = freq * pos.x + phase * time;
                        
                        pos.y += amp * sin(theta);
                        pos.x -= amp * cos(theta) * 0.5; // Crunch effect
                        return pos;
                    }

                    void main() {
                        vUv = uv;
                        vec3 pos = instanceMatrix[3].xyz;
                        float dist = length(pos.xz - uHandPos * 40.0);
                        
                        float h = 0.0;
                        
                        // 1. SUN (LIQUID) STATE
                        // Gentle rolling waves. 
                        // IMPORTANT: We do NOT flatten y to 0. We keep it as a grid but move smoothly.
                        float liqWave = sin(pos.x * 0.2 + uTime) * cos(pos.z * 0.15 + uTime * 0.8) * 1.5;
                        // Hand Interaction
                        float ripple = sin(dist * 0.8 - uTime * 4.0) / (1.0 + dist * 0.2) * 2.0;
                        
                        // 2. STORM STATE
                        // Choppy, high frequency noise
                        float stormWave = (sin(pos.x * 0.8 + uTime * 3.0) + cos(pos.z * 0.9 + uTime * 3.5)) * 1.5;
                        stormWave += sin(dist - uTime * 8.0) * 1.5;

                        // 3. ICE STATE
                        // Vertical growth based on tile type
                        float isVertical = step(0.5, aType) * step(aType, 2.5);
                        float crystalGrowth = isVertical * 8.0;

                        // Mix Heights
                        h += (liqWave + ripple) * wSun;
                        h += stormWave * wStorm;
                        h += crystalGrowth * wIce;

                        vec3 transformed = position;
                        transformed.y += h;

                        vec3 finalPos = pos + transformed;
                        vWorldPos = finalPos;
                        vElevation = h;
                        
                        // Approximate normal for lighting (simplified)
                        vNormal = normal; 
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPos;
                    varying vec3 vNormal;
                    varying float vElevation;

                    uniform float uTime;
                    uniform float wSun;
                    uniform float wStorm;
                    uniform float wIce;
                    
                    uniform vec3 uDeepWater;
                    uniform vec3 uShallowWater;
                    uniform vec3 uSunLight;

                    void main() {
                        // View & Light Directions
                        vec3 viewDir = normalize(cameraPosition - vWorldPos);
                        // Main Light Source (Sun)
                        vec3 lightDir = normalize(vec3(0.5, 0.8, -0.5));
                        
                        // Base Normal
                        vec3 norm = normalize(vNormal);

                        // --- 1. WATER RENDERING (Sun/Liquid) ---
                        // We need to perturb the normal to create "glitter"
                        // High frequency noise based on position
                        float noise = sin(vWorldPos.x * 10.0 + uTime * 3.0) * cos(vWorldPos.z * 10.0 + uTime * 2.5);
                        vec3 waterNorm = normalize(norm + vec3(noise * 0.1, 0.0, noise * 0.1));

                        // Base Color: Deep Blue Gradient based on height
                        vec3 waterColor = mix(uDeepWater, uShallowWater, smoothstep(-2.0, 3.0, vElevation));
                        
                        // Specular Highlight (The Sun Glint)
                        // Sharp specular power for "wet" look
                        vec3 halfVec = normalize(lightDir + viewDir);
                        float NdotH = max(0.0, dot(waterNorm, halfVec));
                        float specular = pow(NdotH, 100.0); // Very sharp for glitter
                        
                        // Combine for Sun State
                        vec3 sunStateColor = waterColor + uSunLight * specular * 1.5;

                        // --- 2. STORM RENDERING ---
                        vec3 stormColor = vec3(0.05, 0.05, 0.08);
                        float foam = smoothstep(2.0, 4.0, vElevation); // White caps
                        vec3 stormStateColor = mix(stormColor, vec3(0.8), foam);

                        // --- 3. ICE RENDERING ---
                        // Fresnel effect for ice
                        float fresnel = pow(1.0 - max(0.0, dot(viewDir, norm)), 3.0);
                        vec3 iceBase = vec3(0.6, 0.9, 1.0);
                        vec3 iceStateColor = iceBase * 0.5 + vec3(1.0) * fresnel;

                        // --- FINAL MIX ---
                        vec3 finalColor = vec3(0.0);
                        finalColor += sunStateColor * wSun;
                        finalColor += stormStateColor * wStorm;
                        finalColor += iceStateColor * wIce;

                        // Tone mapping fix in shader manually if needed, but renderer handles it
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            const tileGeo = new THREE.BoxGeometry(CONFIG.tileSize, 0.2, CONFIG.tileSize);
            const mesh = new THREE.InstancedMesh(tileGeo, tileMaterial, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            const typeArr = new Float32Array(count);
            tileGeo.setAttribute('aType', new THREE.InstancedBufferAttribute(typeArr, 1));

            // --- PARTICLES (Elegant Snowflakes & Rain) ---
            const pCount = 4000;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            const pRand = new Float32Array(pCount);
            
            for(let i=0; i<pCount; i++) {
                pPos[i*3] = (Math.random()-0.5) * 100;
                pPos[i*3+1] = (Math.random()-0.5) * 60;
                pPos[i*3+2] = (Math.random()-0.5) * 60;
                pRand[i] = Math.random();
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            pGeo.setAttribute('aRand', new THREE.BufferAttribute(pRand, 1));

            const partMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    wSun: { value: 1.0 },
                    wStorm: { value: 0.0 },
                    wIce: { value: 0.0 }
                },
                vertexShader: `
                    attribute float aRand;
                    uniform float uTime;
                    uniform float wSun;
                    uniform float wStorm;
                    uniform float wIce;
                    varying float vRand;

                    void main() {
                        vRand = aRand;
                        vec3 pos = position;

                        // Dynamics
                        // Sun: Gentle floating dust
                        vec3 sunMove = vec3(sin(uTime + aRand*10.0), uTime * 2.0, cos(uTime*0.5));
                        
                        // Storm: Fast horizontal rain
                        vec3 stormMove = vec3(uTime * 40.0, -uTime * 40.0, 0.0);
                        
                        // Ice: Gentle spiral snow
                        float angle = uTime * (0.5 + aRand);
                        vec3 iceMove = vec3(cos(angle)*2.0, -uTime * 3.0, sin(angle)*2.0);

                        vec3 move = sunMove * wSun + stormMove * wStorm + iceMove * wIce;
                        pos += move;

                        // Wrap around
                        pos.x = mod(pos.x + 50.0, 100.0) - 50.0;
                        pos.y = mod(pos.y + 30.0, 60.0) - 30.0;
                        pos.z = mod(pos.z + 30.0, 60.0) - 30.0;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = (100.0 / -mvPosition.z) * (wIce > 0.5 ? 2.0 : 0.5); // Snow is bigger
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vRand;
                    uniform float wSun;
                    uniform float wStorm;
                    uniform float wIce;

                    void main() {
                        vec2 uv = gl_PointCoord - 0.5;
                        float dist = length(uv);
                        vec4 col = vec4(0.0);

                        // 1. ICE: Elegant Snowflake
                        if(wIce > 0.01) {
                            // Procedural 6-point star
                            float angle = atan(uv.y, uv.x);
                            float f = cos(angle * 6.0);
                            float r = 0.5 - 0.2 * f; // Snowflake shape
                            float snow = 1.0 - smoothstep(r-0.1, r+0.1, dist*2.0);
                            col += vec4(0.8, 0.9, 1.0, snow * 0.9) * wIce;
                        }

                        // 2. SUN: Golden Motes
                        if(wSun > 0.01) {
                            float circ = 1.0 - smoothstep(0.0, 0.5, dist);
                            col += vec4(1.0, 0.8, 0.4, circ * 0.6) * wSun;
                        }

                        // 3. STORM: Rain Streaks
                        if(wStorm > 0.01) {
                            // Simple blob for rain (motion blur handled by eye/speed in Vertex)
                            float rain = 1.0 - smoothstep(0.0, 0.3, dist);
                            col += vec4(0.5, 0.6, 0.7, rain * 0.5) * wStorm;
                        }

                        if(col.a < 0.01) discard;
                        gl_FragColor = col;
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(pGeo, partMaterial);
            scene.add(particleSystem);

            // --- BLOOM (Glow) ---
            const composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.3; // Allow highlights to bloom
            bloom.strength = 1.0;
            composer.addPass(bloom);

            // --- VISION & LOGIC ---
            const video = document.getElementById('cam-preview');
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            const landmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await new Promise(r => video.onloadeddata = r);
            
            // Interaction State
            const State = { wSun: 1, wStorm: 0, wIce: 0, handPos: new THREE.Vector2(0,0), time: 0 };
            let audio = null;
            let initialized = false;

            // Start Button Logic
            document.getElementById('start-btn').addEventListener('click', () => {
                // Initialize Audio
                if(!audio) audio = new AudioEngine();
                audio.resume();

                // Fade out overlay
                document.getElementById('overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('overlay').style.display = 'none', 1500);
                initialized = true;
            });

            // Loop
            const dummy = new THREE.Object3D();
            const sz = aztec.size;
            const offset = (sz * CONFIG.tileSize) / 2;
            let lastVideoTime = -1;
            let lastHand = null;
            let frame = 0;

            function animate() {
                // 1. Hand Tracking
                let isFist = false;
                let speed = 0;

                if (initialized && video.currentTime !== lastVideoTime) {
                    const res = landmarker.detectForVideo(video, performance.now());
                    lastVideoTime = video.currentTime;

                    if (res.landmarks.length > 0) {
                        const lm = res.landmarks[0];
                        const ix = lm[8].x;
                        const iy = lm[8].y;
                        
                        // Map 0..1 to -1..1
                        State.handPos.set((1-ix)*2-1, -(iy*2-1));

                        if(lastHand) {
                            const dx = ix - lastHand.x;
                            const dy = iy - lastHand.y;
                            speed = Math.sqrt(dx*dx + dy*dy);
                        }
                        lastHand = {x: ix, y: iy};

                        // Fist Detection
                        const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        const palm = Math.hypot(lm[0].x - lm[12].x, lm[0].y - lm[12].y);
                        if(pinch < 0.1 || palm < 0.2) isFist = true;
                    }
                }

                // 2. Logic & Weights
                State.time += 0.01;
                
                // Target Weights
                let tSun=0, tStorm=0, tIce=0;
                if(isFist) tIce = 1;
                else if(speed > 0.04) tStorm = 1;
                else tSun = 1;

                // Smooth Transition
                const k = 0.05;
                State.wSun += (tSun - State.wSun) * k;
                State.wStorm += (tStorm - State.wStorm) * k;
                State.wIce += (tIce - State.wIce) * k;

                // Audio Update
                if(audio) audio.update(State.wSun, State.wStorm, State.wIce);

                // UI Update
                const lbl = document.getElementById('state-label');
                if(State.wIce > 0.5) { lbl.innerText = "CRYSTAL"; lbl.style.color = "#aee"; }
                else if(State.wStorm > 0.5) { lbl.innerText = "CHAOS"; lbl.style.color = "#888"; }
                else { lbl.innerText = "LIQUID"; lbl.style.color = "#fb8"; }

                // 3. Aztec Update (Throttled)
                frame++;
                if(frame % 3 === 0) {
                    const bias = 0.5 + (State.wIce * 0.45);
                    aztec.iterate(bias);

                    let idx = 0;
                    for(let y=0; y<sz; y++) {
                        for(let x=0; x<sz; x++) {
                            const t = aztec.grid[y*sz+x];
                            if(t !== 0) {
                                dummy.position.set(x*CONFIG.tileSize - offset, 0, y*CONFIG.tileSize - offset);
                                dummy.updateMatrix();
                                mesh.setMatrixAt(idx, dummy.matrix);
                                typeArr[idx] = t;
                            } else {
                                dummy.position.set(0,-1000,0);
                                dummy.updateMatrix();
                                mesh.setMatrixAt(idx, dummy.matrix);
                            }
                            idx++;
                        }
                    }
                    mesh.instanceMatrix.needsUpdate = true;
                    tileGeo.attributes.aType.needsUpdate = true;
                }

                // 4. Uniforms
                tileMaterial.uniforms.uTime.value = State.time;
                tileMaterial.uniforms.wSun.value = State.wSun;
                tileMaterial.uniforms.wStorm.value = State.wStorm;
                tileMaterial.uniforms.wIce.value = State.wIce;
                tileMaterial.uniforms.uHandPos.value.lerp(State.handPos, 0.1);

                partMaterial.uniforms.uTime.value = State.time;
                partMaterial.uniforms.wSun.value = State.wSun;
                partMaterial.uniforms.wStorm.value = State.wStorm;
                partMaterial.uniforms.wIce.value = State.wIce;

                // Environment Light Color Morph
                const sunColor = new THREE.Color(0xffaa33).multiplyScalar(State.wSun);
                const stormColor = new THREE.Color(0x444455).multiplyScalar(State.wStorm);
                const iceColor = new THREE.Color(0xaaccff).multiplyScalar(State.wIce);
                sunLight.color.copy(sunColor).add(stormColor).add(iceColor);

                composer.render();
                requestAnimationFrame(animate);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        initVisuals();

    </script>
</body>
</html>
